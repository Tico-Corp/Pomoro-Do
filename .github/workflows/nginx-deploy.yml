name: nginx CI/CD Pipeline with Docker and AWS

# develop-be 브랜치에 push 또는 PR 이벤트가 발생하면 워크플로우가 실행된다.
# nginx 폴더 내의 변경 사항이 있을 때만 워크플로우가 실행
on:
  push:
    branches: [ "feature-be/TICO-148-create-nginx-workflows" ]
    # branches: [ "develop-be" ]
    # paths:
    #   - 'nginx/**'
  pull_request:
    branches: [ "develop-be" ]
    paths:
      - 'nginx/**'
      
env:
  IMAGE_NAME: ${{ secrets.DOCKER_IMAGE_NAME }}nginx:latest
  CONTAINER_NAME: nginx-server

# 해당 Workflow의 Job 목록
jobs:
  build:
  # 이 작업이 실행되는 환경을 정의: 최신 Ubuntu 환경
    runs-on: ubuntu-latest
    # 리포지토리에 대한 읽기 권한을 부여한다.
    permissions:
      contents: read
      
    # build Job 내의 step 목록
    steps:
    # 레포지토리 체크아웃하여 레포지토리에 접근할 수 있게 한다.
    - name: Checkout Repository
      uses: actions/checkout@v4

    # Docker Hub에 로그인 (보안)
    - name: Log in to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    # Nginx Docker 이미지를 빌드하고 Docker Hub에 푸시
    - name: Build and push Nginx Docker image
      run: |
        cd nginx  # nginx 폴더로 이동
        set -e  # 명령 실패 시 스크립트 종료
        # 현재 디렉토리에 있는 Dockerfile을 사용하여 Docker 이미지를 빌드
        docker build -t ${{ env.IMAGE_NAME }} .
        # Docker Hub에 이미지 푸시
        docker push ${{ env.IMAGE_NAME }}

  deploy:
    # 이 작업은 build 작업이 성공적으로 완료된 후에만 실행된다.
    needs: build
    runs-on: ubuntu-latest
    
    steps:
    # SSH를 통해 원격 서버에서 명령을 실행하여 Docker 컨테이너 배포
    - name: Deploy Nginx
      uses: appleboy/ssh-action@v0.1.10
      with:
        host: ${{ secrets.SSH_HOST }}  # 원격 서버의 호스트명
        username: ${{ secrets.SSH_USERNAME }}  # 원격 서버의 사용자명
        key: ${{ secrets.SSH_PRIVATE_KEY }}  # 원격 서버의 비밀 키
        port: 22  # SSH 포트
        sync: false
        use_insecure_cipher: false
        timeout: 30s
        command_timeout: 10m
        debug: true  # 디버그 모드 활성화
        script: |
            set -e  # 명령 실패 시 스크립트 종료
            docker stop ${{ env.CONTAINER_NAME }} || true  # 실행 중인 nginx-server 컨테이너 중지
            docker rm ${{ env.CONTAINER_NAME }} || true  # 기존 컨테이너 삭제
            docker rmi ${{ env.IMAGE_NAME }} || true  # 기존 이미지 삭제
            docker pull ${{ env.IMAGE_NAME }}  # 최신 이미지 다운로드
            docker run -d --name ${{ env.CONTAINER_NAME }} \
              -v /etc/letsencrypt/:/etc/letsencrypt/ \  # 인증서 마운트
              -p 80:80 -p 443:443 \  # 포트 매핑
              ${{ env.IMAGE_NAME }}  # 새로운 컨테이너 실행
